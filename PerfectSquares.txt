//approach - 1 - recursion + memo, top down approach
//time complexity - O(nrootn)
//space complexity - O(n)
class Solution {
public:
    /**
     * Recursive function to find the minimum number of perfect squares that sum up to n.
     * @param n: The current target value to reach.
     * @param memo: DP table to store the results of subproblems (n to avoid recomputation).
     */
    int solve(int n, vector<int> &memo) {
        // Base Case: If n is 0, we need 0 perfect squares to make the sum.
        if(n == 0) {
            return 0;
        }

        // Memoization: If we have already calculated the result for this n, return it.
        if(memo[n] != -1) {
            return memo[n];
        }

        // Initialize minCount with a large value.
        int minCount = INT_MAX;

        // Try every perfect square (i*i) that is less than or equal to n.
        for(int i = 1; i * i <= n; i++) {
            // Recurrence: 1 (for the current square i*i) + minimum squares needed for (n - i*i).
            int result = 1 + solve(n - i * i, memo);

            // Keep track of the minimum count found among all possible choices.
            minCount = min(minCount, result);
        }

        // Store the result in memo before returning to optimize future calls.
        return memo[n] = minCount;
    }

    int numSquares(int n) {
        // Initialize memoization table with -1 (indicating unsolved states).
        // Size is n + 1 to handle indices from 0 to n.
        vector<int> memo(n + 1, -1);
        
        return solve(n, memo);
    }
};
