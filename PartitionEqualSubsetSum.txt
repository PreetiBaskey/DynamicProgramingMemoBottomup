//approach - 1 - using dynamic programming
//time complexity - O(n * half)
//space complexity - O(n * half)
class Solution {
public:
    // Helper function using Recursion + Memoization (Top-Down DP)
    bool solve(vector<int> &nums, vector<vector<int>> &memo, int half, int idx) {
        int n = nums.size();

        // BASE CASE: If remaining sum is 0, we found a valid partition
        if(half == 0) {
            return true;
        }
        // BASE CASE: If we've run out of numbers but haven't reached half sum
        if(idx >= n) {
            return false;
        }

        // MEMOIZATION: If this state (remaining sum, current index) was already solved, return it
        if(memo[half][idx] != -1) {
            return memo[half][idx];
        }

        // OPTION 1: "Take" the current number (only if it doesn't exceed the target)
        int take = false;
        if(half >= nums[idx]) {
            take = solve(nums, memo, half - nums[idx], idx + 1);
        }

        // OPTION 2: "Not Take" the current number and move to the next index
        int notTake = solve(nums, memo, half, idx + 1);

        // Store result in memo table and return true if either path works
        return memo[half][idx] = (take || notTake);
    }

    bool canPartition(vector<int>& nums) {
        int n = nums.size();

        // Calculate total sum of all elements
        int sum = 0;
        for(int i = 0; i < n; i++) {
            sum += nums[i];
        }

        //sum calculating alternative
        //int sum = accumulate(nums.begin(), nums.end(), 0);

        // If total sum is odd, it's impossible to split it into two equal integers
        if(sum % 2 != 0) {
            return false;
        }

        int half = sum / 2;
        
        // Memo table: memo[remaining_sum][current_index]
        // half + 1 rows for sums, 1200 + 1 columns for max array size (based on constraints)
        vector<vector<int>> memo(half + 1, vector<int>(n + 1, -1));

        return solve(nums, memo, half, 0);
    }
};
