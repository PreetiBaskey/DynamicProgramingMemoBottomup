/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

 //appraoch - 1
 //time complexity - O(n)
 //space complexity - O(n) or O(logn)
/**
 * Approach: Bottom-Up Tree DP (Post-order Traversal)
 * Strategy: At each node, we decide between two states:
 * 1. Robbing the current node (cannot rob children).
 * 2. Skipping the current node (can choose to rob or skip children).
 */
class Solution {
public:
    // Returns a vector where:
    // index [0] = Max money if we ROB this node
    // index [1] = Max money if we SKIP this node
    vector<int> goRob(TreeNode* &root) {
        // Base Case: If the tree is empty, we get 0 money from both options
        if(root == NULL) {
            return {0, 0};
        }

        // Recursively get the best choices from the left and right subtrees
        vector<int> left_node_choices = goRob(root->left);
        vector<int> right_node_choices = goRob(root->right);

        vector<int> options = {0, 0};

        // State 0: ROB THIS NODE
        // If we rob this house, we MUST skip its immediate children (index [1])
        options[0] = root->val + left_node_choices[1] + right_node_choices[1];

        // State 1: SKIP THIS NODE
        // If we skip this house, we can choose the best option (rob or skip) 
        // for each child independently.
        options[1] = max(left_node_choices[0], left_node_choices[1]) + 
                     max(right_node_choices[0], right_node_choices[1]);

        return options;
    }

    int rob(TreeNode* root) {
        // Get the two options for the root of the tree
        vector<int> options = goRob(root);

        // The answer is the maximum value between robbing or skipping the root
        return max(options[0], options[1]);
    }
};
